## 本章目标 
- close 与 shutdown 区别
- 进一步改进回射客户程序

### close 与 shutdown 的区别

- close：终止了数据传送的两个方向。（仅仅意味着调用 close 的自身不能通过该套接口从全双工管道中写入和读取数据，并不意味着对方不能写入数据）
close 函数会对套接字引用计数减1，一旦发现套接字引用计数到 0，就会对套接字进行释放，并且会关闭 TCP 两个方向的数据流。

- shutdown：可以有选择的终止某个方向的数据传送或者终止数据传送的两个方向。
- shutdown how = 1 就可以保证对等方接收到一个 `EOF` 字符，而不管其他进程是否已经打开了套接字，而 close 不能保证，直到套接字引用计数减为 0 时才发送。也就是说直到所有的进程都关闭了套接字。
（套接字引用计数：因为套接字可以被多个进程共享，你可以理解为我们给每个套接字都设置了一个积分，如果我们通过 fork 的方式产生子进程，套接字就会积分 +1，如果我们调用一次 close 函数，套接字积分就会 -1）

**补充**：

1、`close` 会关闭连接，并*释放所有连接对应的资源*，而 `shutdown `并*不会释放*掉套接字和所有的资源。

2、`close` 存在引用计数的概念，调用 `close` 之后，引用计数减 1 并且本进程不可使用该套接字，但是如果引用计数不为 0 ，那么其他进程仍然可用该套接字；`shutdown` 会直接使该套接字不可用，别的进程也无法使用。

3、`close` 的引用计数导致不一定会发出 `FIN` 结束报文，因为可能还有其他进程在使用套接字，而 **shutdown 总是会发出 FIN 结束报文**，这在我们打算关闭连接通知对端的时候，是非常重要的。

4、shutdown 函数的 howto 选项，有三个主要选项：
- SHUT_RD(0)：关闭连接的“读”这个方向，对该套接字进行读操作直接返回 EOF。从数据角度来看，套接字上接收缓冲区已有的数据将被丢弃，如果再有新的数据流到达，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。
-  SHUT_WR(1)：**关闭连接的“写”这个方向，这就是常被称为”半关闭“的连接**。此时，不管套接字引用计数的值是多少，都会直接关闭连接的写方向。套接字上发送缓冲区已有的数据将被立即发送出去，并发送一个 FIN 报文给对端。应用程序如果对该套接字进行写操作会报错。
- SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，关闭套接字的读和写两个方向


如果服务端想要在客户端关闭时接受管道中的残留数据，可以使用 shutdown 
